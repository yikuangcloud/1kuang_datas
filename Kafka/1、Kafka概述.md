一、Kafka概述
---
&emsp; Kafka是**一个分布式的基于发布/订阅模式的消息队列**，主要应用于大数据实时处理领域。  

### 1、消息队列
<p align="center">
<img src="https://github.com/Dr11ft/BigDataGuide/blob/master/Pics/Kafka%E6%96%87%E6%A1%A3Pics/%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97%20.png"/>  
<p align="center">
</p>
</p>  

消息队列模式：  
1）**`点对点模式`**（**一对一，消费者主动拉取数据**，消息收到后消息清除）  
<p align="center">
<img src="https://github.com/Dr11ft/BigDataGuide/blob/master/Pics/Kafka%E6%96%87%E6%A1%A3Pics/%E7%82%B9%E5%AF%B9%E7%82%B9%E6%A8%A1%E5%BC%8F.png"/>  
<p align="center">
</p>
</p>  

&emsp; 点对点模型通常是一个基于拉取或者轮询的消息传送模型，这种模型从队列中请求信息，而不是将消息推送到客户端。这个模型的特点是发送到队列的消息被一个且只有一个接收者接收处理，即使有多个消息监听者也是如此。（**缺点**：需要时刻监控队列的消息变化，拉取数据，任务需要时刻开启，浪费资源）

2）**`发布/订阅模式`**（**一对多，数据生产后，推送给所有订阅者**）  
<p align="center">
<img src="https://github.com/Dr11ft/BigDataGuide/blob/master/Pics/Kafka%E6%96%87%E6%A1%A3Pics/%E5%8F%91%E5%B8%83%E8%AE%A2%E9%98%85%E6%A8%A1%E5%BC%8F.png"/>  
<p align="center">
</p>
</p>  

&emsp; 发布订阅模型则是一个基于推送的消息传送模型。发布订阅模型可以有多种不同的订阅者，临时订阅者只在主动监听主题时才接收消息，而持久订阅者则监听主题的所有消息，即使当前订阅者不可用，处于离线状态。（**缺点**：推送消息的速度等没有办法适应所有的订阅者，因为订阅者的性能是不一样的）  

### 2、为什么需要消息队列
1）解耦：  
&emsp; 允许你独立的扩展或修改两边的处理过程，只要确保它们遵守同样的接口约束。  
2）冗余：  
&emsp; 消息队列把数据进行持久化直到它们已经被完全处理，通过这一方式规避了数据丢失风险。许多消息队列所采用的"插入-获取-删除"范式中，在把一个消息从队列中删除之前，需要你的处理系统明确的指出该消息已经被处理完毕，从而确保你的数据被安全的保存直到你使用完毕。  
3）扩展性：  
&emsp; 因为消息队列解耦了你的处理过程，所以增大消息入队和处理的频率是很容易的，只要另外增加处理过程即可。  
4）灵活性 & 峰值处理能力：  
&emsp; 在访问量剧增的情况下，应用仍然需要继续发挥作用，但是这样的突发流量并不常见。如果为以能处理这类峰值访问为标准来投入资源随时待命无疑是巨大的浪费。使用消息队列能够使关键组件顶住突发的访问压力，而不会因为突发的超负荷的请求而完全崩溃。  
5）可恢复性：  
&emsp; 系统的一部分组件失效时，不会影响到整个系统。消息队列降低了进程间的耦合度，所以即使一个处理消息的进程挂掉，加入队列中的消息仍然可以在系统恢复后被处理。  
6）顺序保证：  
&emsp; 在大多使用场景下，数据处理的顺序都很重要。大部分消息队列本来就是排序的，并且能保证数据会按照特定的顺序来处理。（Kafka保证一个Partition内的消息的有序性）  
7）缓冲：  
&emsp; 有助于控制和优化数据流经过系统的速度，解决生产消息和消费消息的处理速度不一致的情况。  
8）异步通信：  
&emsp; 很多时候，用户不想也不需要立即处理消息。消息队列提供了异步处理机制，允许用户把一个消息放入队列，但并不立即处理它。想向队列中放入多少消息就放多少，然后在需要的时候再去处理它们。  

### 3、Kafka架构
整体架构图：  
<p align="center">
<img src="https://github.com/Dr11ft/BigDataGuide/blob/master/Pics/Kafka%E9%9D%A2%E8%AF%95%E9%A2%98Pics/Kafka%E7%AE%80%E5%8D%95%E6%9E%B6%E6%9E%84.jpg"/>  
<p align="center">
</p>
</p>  

Kafka详细架构图：  
<p align="center">
<img src="https://github.com/Dr11ft/BigDataGuide/blob/master/Pics/Kafka%E9%9D%A2%E8%AF%95%E9%A2%98Pics/Kafka%E8%AF%A6%E7%BB%86%E6%9E%B6%E6%9E%84.jpg"/>  
<p align="center">
</p>
</p>  

1）**`Producer`**：消息生产者，就是向kafka broker发消息的客户端；  
2）**`Consumer`**：消息消费者，向kafka broker取消息的客户端；  
3）**`Consumer Group（CG）`**：消费者组，由多个consumer组成。**消费者组内每个消费者负责消费不同分区的数据，一个分区只能由一个消费者消费；消费者组之间互不影响**。所有的消费者都属于某个消费者组，即**消费者组是逻辑上的一个订阅者**。  
4）**`Broker`**：一台kafka服务器就是一个broker。一个集群由多个broker组成。一个broker可以容纳多个topic。  
5）**`Topic`**：可以理解为一个队列，**生产者和消费者面向的都是一个topic**；  
6）**`Partition`**：为了实现扩展性，一个非常大的topic可以分布到多个broker（即服务器）上，**一个topic可以分为多个partition**，每个partition是一个有序的队列；  
7）**`Replication`**：副本，为保证集群中的某个节点发生故障时，**该节点上的partition数据不丢失，且kafka仍然能够继续工作**，kafka提供了副本机制，一个topic的每个分区都有若干个副本，一个leader和若干个follower。  
8）**`leader`**：每个分区多个副本的“主”，生产者发送数据的对象，以及消费者消费数据的对象都是leader。  
9）**`follower`**：每个分区多个副本中的“从”，实时从leader中同步数据，保持和leader数据的同步。leader发生故障时，某个follower会成为新的follower。  





















